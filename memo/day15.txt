day15(java 13일차)
복습 -> 접근제한자 -> 캐스팅 -> 추상 클래스

0.복습
1) 상속
	클래스의 확장
	class 자식클래스명 extends 부모클래스명 {
		//부모멤버, 자식멤버
	}
	단일상속만 있다

2) 생성자
	super()		부모의 생성자
	기본생성자
		매개변수가 없는 생성자
		매개변수가 없더라도 초기화는 {} 영역안에서 가능함
		super() 모든 클래스의 최상위 부모클래스 Object 클래스의 기본 생성자
		상속 관계에서는 super() 해당 부모 클래스의 생성자
	매개변수가 있는 생성자
		매개변수를 통해 객체 생성시 원하는 값으로 초기화하기 위해 사용하는 생성자
		다양한 초기화 옵션을 제공하기 위해 오버로딩 가능함

3) 다형성
	하나의 것이 여러가지 형태를 가질 수 있는 성질
	오버로딩(메소드, 생성자) : 매개변수의 개수, 순서, 타입이 다르면 같은 이름으로 선언가능함
	오버라이딩(메소드) : 상속관계에서 자식클래스에서 부모클래스에 있는 메소드를 재정의함
	참조변수의 다형성(매개변수의 다형성) - 캐스팅

4) this, this(), super, super()
	this : 객체 자기자신(참조값)
	this() : 자기자신의 생성자
	super : 부모의 참조값
	super() : 부모의 생성자

5) 접근 제한자
	접근제한자		제한대상			제한범위
	public		클래스,필드,생성자,메소드	없음
	protected	필드,생성자,메소드		같은 패키지거나 상속관계에서 자식객체만 사용가능
	(default)	클래스,필드,생성자,메소드	같은 패키지
	private		필드,생성자,메소드		같은 클래스


1. 접근 제한자(private)
1) setter, getter(단축키 : alt + shift + s + r) 

	setter, getter 접근 제한자는 public 이다
	setter 메소드는 매개변수로 값을 저장만 해줄 것이기 때문에 리턴타입은 void
	메소드명 setter에서 set을 따오고 + 필드이름(첫글자는 대문자), 카멜표기법
	매개변수 타입은 필드 타입
	
	getter 메소드는 값을 외부로 리턴해줘야하기 때문에 리턴타입은 필드의 타입으로 설정
	메소드명은 getter에서 get을 따오고 + 필드이름(첫글자는 대문자), 카멜표기법
	리턴값은 필드값

+) 객체의 필드(데이터)를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있다
	학생 점수는 음수가 될 수 없는데 외부에서 음수로 변경하면 객체의 무결성이 깨진다
	객체지향 프로그래밍에서는 직접적인 외부에서의 필드 접근을 막고 대신 메소드를 통해 필드에 접근하는 것을 권장한다.
	메소드는 데이터를 검증해서 유효한 값만 필드에 저장할 수 있기 때문이다
	이 역할을 하는 것이 setter 메소드이다
	외부에서 객체의 필드를 읽을 때도 메소드가 필요한 경우가 있다
	필드값이 객체 외부에서 사용하기 부적절한 경우 메소드도 적절한 값으로 변환하여 리턴할 수 있기 때문이다
	이런 역할을 하는 것이 getter 메소드이다
	=> 캡슐화, 은닉화

2. final 클래스와 final 메소드
	final 최종을 의미하는 키워드
	final 클래스 : 최종적인 클래스이므로 더이상 상속할 수 없는 클래스
			부모클래스가 될 수 없으므로 자식클래스를 만들 수 없다
		대표적인 클래스 : String 클래스

	final 메소드 : 최종적인 메소드이므로 오버라이딩을 할 수 없는 메소드가 된다
		부모클래스의 메소드에서 final을 사용하면 자식 클래스에서 재정의 할 수 없다

3. Casting ★★★★★
1) Up Casting
	자식값을 부모 타입으로 형변환(자동 타입 변환)
	부모타입 참조변수 = 자식타입객체;
	
	부모클래스 타입의 참조변수로 자식 클래스의 객체를 가리킬 수 있다
	업 캐스팅 후에는 부모 클래스의 멤버(필드와 메소드)에만 접근할 수 있다
	자식 클래스의 멤버는 참조할 수 없지만 객체 내부에는 여전히 자식 클래스의 멤버가 존재한다
	명시적 캐스팅이 생략 가능

	부모클래스타입 참조변수 = (부모클래스타입) new 자식클래스생성자();
	부모클래스타입 참조변수 = (부모클래스타입) 자식객체;
	부모클래스타입 참조변수 = new 자식클래스생성자();
 
	
2) Down Casting 
	이미 Up Casting 된 객체를 자식 타입으로 형 변환
	※ 부모 값을 자식 타입으로 형 변환시 오류 발생
	※ 자식 클래스 타입의 객체는 부모 클래스 타입도 동시에 갖는다
			
	업 캐스팅 된 객체를 다시 자식 클래스 타입으로 변환하는 것을 의미하며
	명시적 캐스팅이 필요하다
	다운 캐스팅 후에는 자식클래스의 멤버(필드와 메소드)에 접근할 수 있다
	잘못된 다운캐스팅(자식타입의 객체에 부모 타입의 주소값을 저장, 부모객체를 자식타입으로 변환시도)는 	ClassCastException 예외가 발생한다
	
3) Casting을 사용하는 이유
	부모타입인 하나의 저장공간에 여러 자식 타입의 참조값을 업 캐스팅하여 저장할 수 있다(참조변수의 다형성)
	만약 하나의 기능을 하는 메소드를 만들 때 매개변수로 여러 자식타입을 각각 받아야한다고 하면 가정하고
	Casting이 없었다면 자식 타입을 매개변수로 받는 메소드를 타입별로 각각 만들어야 한다
	(자식끼리는 타입이 다르기 때문이다)
	Casting을 활용하면 부모타입의 매개변수를 가진 하나의 메소드만 만들면 된다
	(부모타입의 참조변수로 모든 자식 타입을 저장할 수 있기 때문이다)
	
※주의사항
	- 업 캐스팅된 자식의 참조값을 저장했다면 자식 클래스에 오버라이딩 된 기능이 실행된다
	- 업 캐스팅된 자식의 참조값을 저장했다면 자식 클래스에서 구현한 기능들은 사용할 수 없다
	이 경우 Down Casting을 통해서 복구하고 사용한다

4) 다형성
	하나의 것이 여러가지 형태를 가질 수 있는 성질
	- 오버로딩	 : 생성자, 메소드
		같은 이름으로 매개변수의 타입, 순서, 개수가 다르면 선언할 수 있다
		반환타입은 영향을 끼치지 않는다	
	- 오버라이딩 :상속받은 자식 클래스의 메소드
		부모클래스에 정의된 메소드 선언부를 그대로 쓰고 구현부만 재정의
		선언부는 무조건 동일해야 한다
	- 참조변수의 다형성(매개변수의 다형성) : 메소드 매개변수(상속 관계에서 부모클래스 타입)
		부모 클래스타입의 참조변수로 자식 클래스 객체를 가리키는 것을 허용하는 것을 의미한다

5) 객체 간 타입 비교
	객체명 instanceof 클래스타입
	a instanceof A : 조건식, 참 / 거짓 중 하나가 나오는 식
		a가 A클래스 타입이면 true
		a가 A클래스 타입이 아니면 false








